<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Business English Expression Game</title>

    <style>
        /* --- CSS Code --- */
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #e0e0e0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden; /* Prevent body scroll due to falling words */
        }

        #game-container {
            width: 90vw;
            max-width: 800px;
            border: 5px solid #333;
            background-color: #f8f8f8;
            position: relative;
            overflow: hidden; /* Crucial for clipping falling words */
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.4);
            border-radius: 10px;
        }

        #hud {
            display: flex;
            justify-content: space-between;
            padding: 10px 15px;
            background-color: #2c3e50; /* Dark blue/grey */
            color: white;
            font-size: 1.1em;
            font-weight: bold;
            border-bottom: 2px solid #34495e;
        }

        #game-frame {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); /* Flexible columns */
            gap: 8px; /* Space between words */
            padding: 15px;
            min-height: 350px; /* Minimum height for the mosaic */
            align-items: center;
            justify-items: center;
            transition: all 0.5s ease-in-out; /* Smooth shrinking transition */
            background-color: #ecf0f1; /* Light background for mosaic */
        }

        .word-tile {
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            font-weight: bold;
            color: white;
            box-shadow: 2px 4px 8px rgba(0,0,0,0.3);
            transition: transform 0.2s ease-out, opacity 0.2s ease-out, background-color 0.2s ease-in-out;
            position: relative;
            white-space: nowrap; /* Prevent words from breaking */
            user-select: none; /* Prevent text selection */
            min-width: 60px; /* Ensure a minimum width for small words */
        }

        .word-tile:hover {
            transform: translateY(-3px);
            box-shadow: 3px 5px 10px rgba(0,0,0,0.4);
        }

        /* Incorrect word shake animation */
        .incorrect-shake {
            animation: shake 0.3s ease-in-out 2;
        }

        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-8px); }
            50% { transform: translateX(8px); }
            75% { transform: translateX(-8px); }
            100% { transform: translateX(0); }
        }

        /* "Falling out" animation for correct words */
        .falling {
            animation: fallAndFade 0.8s forwards;
            pointer-events: none; /* Disable clicks during fall */
            position: fixed; /* Use fixed to fall relative to viewport, not just parent */
            left: var(--start-left); /* Custom CSS properties set by JS */
            top: var(--start-top);   /* Custom CSS properties set by JS */
            z-index: 10; /* Ensure it's on top while falling */
        }

        @keyframes fallAndFade {
            0% {
                transform: translateY(0);
                opacity: 1;
            }
            100% {
                transform: translateY(calc(100vh + 100px)); /* Fall completely off screen */
                opacity: 0;
            }
        }

        #definition-display-wrapper {
            background-color: #34495e; /* Slightly darker than HUD */
            color: white;
            padding: 12px 15px;
            text-align: center;
            white-space: nowrap; /* Keep text on one line for scrolling */
            overflow: hidden; /* Hide overflow for scrolling effect */
            border-top: 2px solid #2c3e50;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;
        }

        #definition-display {
            display: inline-block; /* Essential for scrolling animation */
            padding-left: 100%; /* Start off-screen */
            animation: scroll-text 20s linear infinite; /* Adjust duration as needed */
            font-size: 1.1em;
        }

        @keyframes scroll-text {
            0% { transform: translateX(0%); }
            100% { transform: translateX(-100%); }
        }

        /* Pause scroll when definition is not needed or game over */
        #definition-display.paused-scroll {
            animation-play-state: paused;
            transform: translateX(0) !important; /* Reset position */
            padding-left: 0;
        }

        #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 2.2em;
            text-align: center;
            z-index: 20;
            border-radius: 10px;
            padding: 20px;
            box-sizing: border-box;
        }

        #game-over-screen h2 {
            color: #e74c3c; /* Red for Game Over */
            margin-bottom: 20px;
            font-size: 1.5em;
        }

        #game-over-screen p {
            font-size: 0.8em;
            margin-bottom: 25px;
            line-height: 1.4;
            max-width: 80%;
        }

        #play-again-button {
            padding: 12px 25px;
            font-size: 0.7em;
            font-weight: bold;
            color: white;
            background-color: #2ecc71; /* Green */
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        #play-again-button:hover {
            background-color: #27ae60;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <div id="hud">
            <div id="round-indicator">Round: 1/20</div>
            <div id="timer-display">Total Time: 0:00</div> <div id="lives-indicator">Lives: ❤️❤️❤️</div>
        </div>

        <div id="game-frame">
            </div>

        <div id="definition-display-wrapper">
            <div id="definition-display"></div>
        </div>

        <div id="game-over-screen" class="hidden">
            <h2>GAME OVER!</h2>
            <p id="final-score">Your final score: 0</p>
            <p id="final-time">Total time: 0:00</p> <button id="play-again-button">Play Again?</button>
        </div>
    </div>

    <audio id="correct-sound" src="sounds/correct.mp3" preload="auto"></audio>
    <audio id="incorrect-sound" src="sounds/incorrect.mp3" preload="auto"></audio>
    <audio id="round-complete-sound" src="sounds/round_complete.mp3" preload="auto"></audio>
    <audio id="game-over-sound" src="sounds/game_over.mp3" preload="auto"></audio>

    <script>
        /* --- JavaScript Code --- */

        // --- Global Game Variables ---
        let currentLives = 3;
        let score = 0;
        let roundNumber = 0; // 0-indexed, so Round 1 is roundNumber 0
        let gameTimerInterval;
        let totalGameTime = 0; // Stopwatch: counts total time in seconds
        let incorrectAttemptsThisRound = 0; // Counts incorrect attempts within the current round
        let usedExpressions = new Set(); // To track completed expressions

        let currentExpression = null; // Object for the current round's expression
        let wordsToSelectInOrder = []; // The exact words in order for current expression
        let selectedWordsCount = 0; // How many correct words have been selected for the current round

        // --- DOM Elements ---
        const gameContainer = document.getElementById('game-container');
        const hud = document.getElementById('hud');
        const gameFrame = document.getElementById('game-frame');
        const definitionDisplayWrapper = document.getElementById('definition-display-wrapper');
        const definitionDisplay = document.getElementById('definition-display');
        const livesIndicator = document.getElementById('lives-indicator');
        const timerDisplay = document.getElementById('timer-display');
        const roundIndicator = document.getElementById('round-indicator');
        const correctSound = document.getElementById('correct-sound');
        const incorrectSound = document.getElementById('incorrect-sound');
        const roundCompleteSound = document.getElementById('round-complete-sound');
        const gameOverSound = document.getElementById('game-over-sound');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreDisplay = document.getElementById('final-score');
        const finalTimeDisplay = document.getElementById('final-time'); // For total time display
        const playAgainButton = document.getElementById('play-again-button');


        // --- Game Data (from your provided list) ---
        const expressionsData = [
            { expression: ["go", "soft", "on"], definition: "treat someone delicately, leniently and/or not criticize someone too harshly" },
            { expression: ["harp", "on"], definition: "keep talking or complaining about someone or something" },
            { expression: ["slave", "away"], definition: "work incredibly hard and often continuously on/at something" },
            { expression: ["nothing", "short", "of"], definition: "emphasize a situation, quality, or type of behavior" },
            { expression: ["plug", "along", "or", "away"], definition: "make steady progress - especially in the face of difficulties, challenges or setbacks" },
            { expression: ["tread", "lightly"], definition: "be extra cautious and tactful when dealing with someone in order to avoid offending or aggravating him/her" },
            { expression: ["pull", "something", "off"], definition: "accomplish whatever that may have been despite the challenges and/or hardships" },
            { expression: ["on", "one’s", "own", "account"], definition: "do something without being given instructions, prompting or guidance from others" },
            { expression: ["take", "issue", "with"], definition: "strongly disagree with someone or something" },
            { expression: ["cry", "foul"], definition: "complain or protest against something bad/illegal that has happened" },
            { expression: ["out", "of", "the", "woods"], definition: "be out of danger or difficulty" },
            { expression: ["fly", "off", "the", "handle"], definition: "suddenly lose one’s temper" },
            { expression: ["the", "devil", "is", "in", "the", "details"], definition: "pay close attention to the details of something may cause unexpected problems" },
            { expression: ["in", "the", "ballpark"], definition: "when someone's ideas, actions, or estimates are approximately correct" },
            { expression: ["go", "out", "on", "a", "limb"], definition: "act with conviction despite the potential danger and/or criticism" },
            { expression: ["off", "base"], definition: "be wrong/incorrect, mistaken or misinformed" },
            { expression: ["the", "homestretch"], definition: "approach the final stage of an undertaking" },
            { expression: ["rant", "and", "rave"], definition: "complain loudly or forcefully and usually at length about that" },
            { expression: ["in", "and", "of", "itself"], definition: "something being considered independently apart from any other factors" },
            { expression: ["hit/punch", "below", "the", "belt"], definition: "unfairly target someone’s weaknesses or vulnerabilities" }
        ];

        // Global Variable to store all unique words once for decoy generation
        let allUniqueWordsPool = [];

        // --- Initial Setup on Page Load ---
        document.addEventListener('DOMContentLoaded', () => {
            alert('DOMContentLoaded fired! Initializing game...'); // Debug alert
            initGame();
            alert('Game initialized. Populating word pool...'); // Debug alert
            populateAllUniqueWordsPool(); // Populate this once on initial page load
            alert('Word pool populated. Starting first round...'); // Debug alert
        });


        // --- Game Initialization ---
        function initGame() {
            currentLives = 3;
            score = 0;
            roundNumber = 0; // Reset to 0 for the first round
            totalGameTime = 0; // Reset stopwatch
            usedExpressions.clear();

            // Ensure game elements are visible and game over screen is hidden
            hud.style.display = 'flex';
            gameFrame.style.display = 'grid';
            definitionDisplayWrapper.style.display = 'block';
            gameOverScreen.classList.add('hidden');

            updateHUD();
            startGameTimer(); // Start the stopwatch
            startNewRound();

            // Re-attach playAgainButton listener (important for subsequent plays)
            playAgainButton.removeEventListener('click', initGame); // Remove previous to prevent multiple listeners
            playAgainButton.addEventListener('click', initGame);
        }

        // Function to gather all unique words from all expressions
        function populateAllUniqueWordsPool() {
            const uniqueWordsSet = new Set();
            expressionsData.forEach(expr => {
                expr.expression.forEach(word => uniqueWordsSet.add(word));
            });
            allUniqueWordsPool = Array.from(uniqueWordsSet);
        }

        // --- HUD Updates ---
        function updateHUD() {
            livesIndicator.textContent = 'Lives: ' + '❤️'.repeat(currentLives);
            // Display total game time as stopwatch (MM:SS format)
            const minutes = Math.floor(totalGameTime / 60);
            const seconds = totalGameTime % 60;
            timerDisplay.textContent = `Total Time: ${minutes}:${seconds.toString().padStart(2, '0')}`;
            // Display roundNumber + 1 because roundNumber is 0-indexed
            roundIndicator.textContent = `Round: ${roundNumber + 1}/20`;
        }

        // --- Game Timer (Stopwatch) ---
        function startGameTimer() {
            clearInterval(gameTimerInterval); // Clear any existing timer
            gameTimerInterval = setInterval(() => {
                totalGameTime++; // Increment stopwatch
                updateHUD();
            }, 1000);
        }

        // --- Round Management ---
        function startNewRound() {
            alert('Entering startNewRound(). Round Number: ' + (roundNumber + 1) + '. Expressions Data Length: ' + expressionsData.length); // Debug alert

            // Check for game completion (all expressions used OR max rounds reached)
            if (roundNumber >= expressionsData.length || roundNumber >= 20) { // Max 20 rounds or all expressions
                alert('Game completion condition met. Ending game.'); // Debug alert
                endGame();
                return;
            }

            roundNumber++; // Increment round for the new round
            updateHUD();
            incorrectAttemptsThisRound = 0; // Reset for the new round
            selectedWordsCount = 0; // Reset for the new round

            // 1. Select a unique expression
            let availableExpressions = expressionsData.filter(expr => !usedExpressions.has(expr.expression.join(' ')));
            if (availableExpressions.length === 0) {
                alert('No available expressions left. Ending game.'); // Debug alert
                endGame(); // All expressions used up, end game (e.g., if there are < 20 expressions)
                return;
            }
            const randomIndex = Math.floor(Math.random() * availableExpressions.length);
            currentExpression = availableExpressions[randomIndex];
            usedExpressions.add(currentExpression.expression.join(' ')); // Mark as used

            wordsToSelectInOrder = [...currentExpression.expression]; // The exact sequence of words needed
            alert('Current Expression selected: ' + currentExpression.expression.join(' ') + '. Definition: ' + currentExpression.definition); // Debug alert

            // 2. Prepare mosaic words (with dynamic decoys)
            let wordsForMosaic = [...currentExpression.expression]; // Always include the current expression's words

            // Determine the percentage of the full word pool to include as decoys
            // Grows from 0% in Round 1 (roundNumber = 1) to 100% by Round 8 (roundNumber = 8)
            const decoyGrowthRounds = 7; // Rounds 2 through 8 (8 - 1 = 7 steps)
            const decoyPoolPercentage = Math.min(1, (roundNumber - 1) / decoyGrowthRounds);

            if (decoyPoolPercentage > 0) {
                // Filter out current expression words from the full unique pool to get pure decoys
                const potentialDecoys = allUniqueWordsPool.filter(word => !currentExpression.expression.includes(word));

                // Calculate how many decoys to add based on the percentage
                const numDecoysToAdd = Math.ceil(potentialDecoys.length * decoyPoolPercentage);

                // Add a shuffled subset of these decoys
                wordsForMosaic = wordsForMosaic.concat(shuffleArray(potentialDecoys).slice(0, numDecoysToAdd));
            }

            wordsForMosaic = shuffleArray(wordsForMosaic); // Shuffle the final mosaic words for the round

            alert('Rendering mosaic with ' + wordsForMosaic.length + ' words.'); // Debug alert
            renderMosaic(wordsForMosaic);
            startDefinitionScroll();
            alert('Round setup complete. Definition should be scrolling.'); // Debug alert
        }

        function renderMosaic(words) {
            gameFrame.innerHTML = ''; // Clear previous mosaic

            // Adjust grid columns based on the number of words to maintain dynamic sizing
            const numWords = words.length;
            let idealColumns = Math.ceil(Math.sqrt(numWords)); // Attempt a somewhat square layout
            let minTileWidth = 80; // Matches CSS minmax
            let maxPossibleColumns = Math.floor(gameFrame.offsetWidth / minTileWidth);
            let finalColumns = Math.max(1, Math.min(idealColumns, maxPossibleColumns));
            gameFrame.style.gridTemplateColumns = `repeat(${finalColumns}, minmax(${minTileWidth}px, 1fr))`;

            words.forEach(word => {
                const wordTile = document.createElement('div');
                wordTile.textContent = word;
                wordTile.classList.add('word-tile');
                wordTile.dataset.word = word; // Store the word for checking
                wordTile.style.backgroundColor = getRandomColor();
                wordTile.addEventListener('click', handleWordClick);
                gameFrame.appendChild(wordTile);
            });
        }

        function startDefinitionScroll() {
            definitionDisplay.textContent = currentExpression.definition;
            definitionDisplay.classList.remove('paused-scroll');
            definitionDisplay.style.animationPlayState = 'running'; // Ensure animation runs
        }

        function stopDefinitionScroll() {
            definitionDisplay.classList.add('paused-scroll');
            definitionDisplay.style.animationPlayState = 'paused'; // Pause animation
        }

        // --- Player Interaction ---
        function handleWordClick(event) {
            const clickedWordTile = event.target;
            const clickedWord = clickedWordTile.dataset.word;

            const expectedWord = wordsToSelectInOrder[selectedWordsCount];

            if (clickedWord === expectedWord) {
                correctSound.play();
                selectedWordsCount++;

                // Get the exact position of the tile relative to the viewport
                const rect = clickedWordTile.getBoundingClientRect();
                clickedWordTile.style.setProperty('--start-left', `${rect.left}px`);
                clickedWordTile.style.setProperty('--start-top', `${rect.top}px`);

                clickedWordTile.classList.add('falling'); // Start falling animation
                clickedWordTile.removeEventListener('click', handleWordClick); // Disable clicks

                // Remove the element from the DOM after the animation has time to start/complete
                setTimeout(() => {
                    if (clickedWordTile.parentNode) {
                        clickedWordTile.parentNode.removeChild(clickedWordTile);
                    }
                }, 750); // Slightly less than animation duration to avoid visual glitches

                if (selectedWordsCount === wordsToSelectInOrder.length) {
                    // Expression completed!
                    score += 100;
                    stopDefinitionScroll();
                    roundCompleteSound.play();
                    // A short delay before starting the next round to let sounds play and animations settle
                    setTimeout(startNewRound, 1800);
                }
            } else {
                // Incorrect word
                incorrectAttemptsThisRound++;
                incorrectSound.play();
                clicked